<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Rehabit – Guided Rehab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <script src="https://unpkg.com/lottie-web@5.12.2/build/player/lottie.min.js"></script>
  <style>
    :root{
      --bg: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      --surface: rgba(30, 35, 55, 0.85);
      --surface-hover: rgba(40, 45, 65, 0.9);
      --border: rgba(99, 110, 140, 0.2);
      --text: #f0f4ff;
      --muted: #9ca9c3;
      --accent: #6366f1;
      --accent-glow: rgba(99, 102, 241, 0.4);
      --good: #10b981;
      --good-glow: rgba(16, 185, 129, 0.3);
      --radius: 16px;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;overflow-x:hidden}
    body{background:var(--bg);background-attachment:fixed;color:var(--text);font-family:'Outfit',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.6}
    @keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
    @keyframes slideIn{from{opacity:0;transform:translateX(-30px)}to{opacity:1;transform:translateX(0)}}
    @keyframes pulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.05);opacity:.85}}
    .wrap{max-width:1400px;margin:0 auto;padding:24px 20px;animation:fadeIn .6s}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:32px;padding:16px 24px;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);backdrop-filter:blur(10px);animation:slideIn .5s}
    .brand{display:flex;align-items:center;gap:12px;font-weight:800;font-size:24px;background:linear-gradient(135deg,#6366f1,#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .chip{background:linear-gradient(135deg,var(--accent),#8b5cf6);padding:8px 16px;border-radius:999px;font-weight:700;font-size:14px;color:#fff;box-shadow:0 4px 16px var(--accent-glow);animation:pulse 2s infinite}
    .status{display:flex;align-items:center;gap:8px;padding:8px 16px;background:rgba(16,185,129,.1);border:1px solid var(--good);border-radius:999px}
    .grid{display:grid;grid-template-columns:1.4fr 1fr;gap:24px}
    @media (max-width:1024px){.grid{grid-template-columns:1fr}}
    .pane{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);backdrop-filter:blur(20px);transition:.3s;animation:fadeIn .7s}
    .pane:hover{border-color:rgba(99,110,140,.4);transform:translateY(-2px);box-shadow:0 8px 32px rgba(0,0,0,.3)}
    .pane-body{padding:20px}

    /* VIDEO + OVERLAY */
    .video-box{position:relative;border-radius:var(--radius);overflow:hidden;border:2px solid var(--border);background:#000;box-shadow:0 8px 32px rgba(0,0,0,.4); aspect-ratio:16/9;}
    video{display:block;width:100%;height:auto}
    canvas.overlay{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:2}

    .hudbar{position:absolute;left:16px;right:16px;bottom:16px;display:flex;align-items:center;justify-content:space-between;background:rgba(10,14,39,.9);border:1px solid var(--border);border-radius:12px;padding:12px 16px;backdrop-filter:blur(10px)}
    .cue{font-weight:600;font-size:15px}
    .dot{width:10px;height:10px;border-radius:50%;background:#6b7280;transition:.3s}
    .dot.ok{background:var(--good);box-shadow:0 0 12px var(--good-glow);animation:pulse 1.5s infinite}

    .controls{display:flex;gap:12px;margin-top:16px;flex-wrap:wrap}
    .btn{appearance:none;border:none;background:rgba(30,35,55,.6);border:1px solid var(--border);color:var(--text);padding:12px 24px;border-radius:12px;font-weight:600;font-size:14px;cursor:pointer;transition:.3s}
    .btn:hover:not(:disabled){background:var(--surface-hover);transform:translateY(-2px);box-shadow:0 4px 16px rgba(0,0,0,.2)}
    .btn.primary{background:linear-gradient(135deg,var(--accent),#8b5cf6);color:#fff;border:none;box-shadow:0 4px 20px var(--accent-glow);font-weight:700}
    .btn.primary:hover:not(:disabled){box-shadow:0 6px 28px var(--accent-glow);transform:translateY(-3px)}
    .btn:disabled{opacity:.4;cursor:not-allowed;transform:none}

    .step-head{display:flex;align-items:center;justify-content:space-between;padding:20px 24px;border-bottom:1px solid var(--border);background:linear-gradient(135deg,rgba(99,102,241,.05),rgba(139,92,246,.05))}
    .title{font-weight:800;font-size:20px;background:linear-gradient(135deg,var(--text),var(--muted));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .rep-big{font-size:52px;font-weight:800;line-height:1;background:linear-gradient(135deg,var(--accent),#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .rep-sub{color:var(--muted);font-size:13px;margin-top:4px;font-weight:500}
    .step-body{padding:24px;display:grid;gap:16px}
    .anim{height:220px;border:2px solid var(--border);border-radius:14px;background:linear-gradient(135deg,rgba(10,14,39,.8),rgba(30,35,55,.6));overflow:hidden}
    .tips{border:2px dashed var(--border);border-radius:12px;padding:12px;font-size:14px;background:rgba(99,102,241,.05);line-height:1.8}
    .progress{height:10px;background:rgba(10,14,39,.6);border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .progress span{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),#8b5cf6);transition:width .5s;box-shadow:0 0 20px var(--accent-glow)}

    /* Metrics panel */
    .metrics{border:1px solid var(--border);border-radius:12px;background:rgba(9,13,25,.5);padding:12px;max-height:240px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;white-space:pre-wrap}

    /* Intro overlay */
    .intro{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.85);backdrop-filter:blur(8px);padding:20px;z-index:100;animation:fadeIn .4s}
    .intro-card{width:min(960px,100%);background:var(--surface);border:2px solid var(--border);border-radius:24px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
    .intro-head{display:flex;align-items:center;justify-content:space-between;padding:24px 28px;border-bottom:1px solid var(--border);background:linear-gradient(135deg,rgba(99,102,241,.1),rgba(139,92,246,.1))}
    .intro-body{display:grid;grid-template-columns:1.2fr 1fr;gap:24px;padding:24px}
    @media (max-width:860px){.intro-body{grid-template-columns:1fr}}
    .intro-anim{height:320px;border:2px solid var(--border);border-radius:16px;background:linear-gradient(135deg,rgba(10,14,39,.9),rgba(30,35,55,.7));overflow:hidden}
    .intro-list{font-size:15px;color:var(--text);margin:0;padding-left:24px;display:grid;gap:10px;line-height:1.8}
    .intro-foot{display:flex;align-items:center;justify-content:space-between;gap:16px;padding:20px 24px;border-top:1px solid var(--border);background:rgba(10,14,39,.4)}
    .count{font-size:56px;font-weight:800;background:linear-gradient(135deg,var(--accent),#8b5cf6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;min-width:72px;text-align:center}

    .score-banner{
        margin-top:12px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:12px 16px;
        border:1px solid var(--border);
        border-radius:12px;
        background:rgba(16,185,129,.08);
        box-shadow:0 4px 16px rgba(0,0,0,.15);
      }
      .score-banner strong{
        font-size:28px;
        font-weight:800;
        background:linear-gradient(135deg,var(--good),#34d399);
        -webkit-background-clip:text;
        -webkit-text-fill-color:transparent;
        background-clip:text;
      }
      .ai-box{
        margin-top:12px;
        border:1px solid var(--border);
        border-radius:12px;
        background:rgba(30,35,55,.7);
        padding:14px 16px;
        box-shadow:0 6px 18px rgba(0,0,0,.22);
      }
      .ai-title{
        font-weight:800;
        font-size:14px;
        letter-spacing:.3px;
        color:#c7d2fe;
        margin-bottom:8px;
        text-transform:uppercase;
      }
      .ai-body{
        font-size:14px;
        color:var(--text);
        line-height:1.7;
        white-space:pre-wrap;
      }
      .ai-links{
        margin-top:8px;
        font-size:12px;
        color:var(--muted);
        display:flex;
        align-items:center;
        gap:8px;
      }
      .ai-links a{
        color:#a5b4fc;
        text-decoration:none;
      }
      .ai-links a:hover{
        text-decoration:underline;
      }
      
      
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand"><span class="chip">Rehabit</span>Guided Rehab</div>
      <div class="status"><span class="dot ok"></span><span style="font-weight:600;font-size:14px">Ready to Start</span></div>
    </header>

    <div class="grid">
      <!-- Camera -->
      <section class="pane">
        <div class="video-box">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="overlay" class="overlay"></canvas>
          <div class="hudbar">
            <div class="cue" id="cueText">Connected. Click Start when ready.</div>
            <div class="dot" id="streamDot"></div>
          </div>
        </div>
        <div class="pane-body">
          <div class="controls">
            <button class="btn primary" id="btnStart">Start Session</button>
            <button class="btn" id="btnStop" disabled>Stop</button>
            <button class="btn" id="btnToggleCam">Hide Video</button>
          </div>
        </div>
      </section>
      <!-- Step & Metrics -->
      <aside class="pane">
        <div class="step-head">
          <div>
            <div class="title" id="stepTitle">Not started</div>
            <div class="rep-sub" id="stepSub">—</div>
          </div>
          <div class="rep-big"><span id="repsDone">0</span>/<span id="repsTarget">0</span></div>
        </div>
        <div class="step-body">
          <div class="anim" id="stepAnim"></div>
          <div class="tips" id="tipsBox">This panel will show tips for the current exercise.</div>
          <div class="progress"><span id="progressBar"></span></div>
          <div class="metrics" id="metricsBox">Metrics will appear here…</div>
        </div>
      </aside>
    </div>
  </div>

  <div id="scoreBanner" class="score-banner" style="display:none;">
    <span>Overall Score</span>
    <strong id="scoreValue">0</strong>
  </div>
  <div class="ai-box" id="aiBox">
    <div class="ai-title">AI Coach Feedback</div>
    <div class="ai-body" id="aiContent">Finish the session to see your personalized feedback…</div>
    <div class="ai-links" id="aiLinks" style="display:none;">
      <a id="jsonLink" href="#" target="_blank">View session JSON</a>
      <span aria-hidden="true">•</span>
      <a href="/api/reports" target="_blank">All reports</a>
    </div>
  </div>

  <!-- How-to overlay -->
  <div class="intro" id="introOverlay">
    <div class="intro-card">
      <div class="intro-head"><div class="title" id="introTitle">Get ready…</div></div>
      <div class="intro-body">
        <div class="intro-anim" id="introAnim"></div>
        <ol class="intro-list" id="introList">
          <li>Make sure the correct joints are visible for this exercise.</li>
          <li>Follow the animation on the left.</li>
          <li>We’ll start automatically after the countdown.</li>
        </ol>
      </div>
      <div class="intro-foot">
        <div class="cue" id="introMessage">Starting in…</div>
        <div class="count" id="introCountdown">3</div>
        <button class="btn" id="introSkip">Skip Intro</button>
      </div>
    </div>
  </div>

<script>
/* ======= UI refs ======= */
const ui = {
  video: document.getElementById('video'),
  overlay: document.getElementById('overlay'),
  cue: document.getElementById('cueText'),
  dot: document.getElementById('streamDot'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnToggle: document.getElementById('btnToggleCam'),
  stepTitle: document.getElementById('stepTitle'),
  stepSub: document.getElementById('stepSub'),
  repsDone: document.getElementById('repsDone'),
  repsTarget: document.getElementById('repsTarget'),
  progress: document.getElementById('progressBar'),
  stepAnim: document.getElementById('stepAnim'),
  metrics: document.getElementById('metricsBox'),
  aiBox: document.getElementById('aiBox'),
  aiContent: document.getElementById('aiContent'),
  aiLinks: document.getElementById('aiLinks'),
  jsonLink: document.getElementById('jsonLink'),
  intro: {
    el: document.getElementById('introOverlay'),
    title: document.getElementById('introTitle'),
    anim: document.getElementById('introAnim'),
    list: document.getElementById('introList'),
    countdown: document.getElementById('introCountdown'),
    skip: document.getElementById('introSkip'),
    message: document.getElementById('introMessage'),
  },
  tips: document.getElementById('tipsBox'),
};

const socket = io();
let stream = null, timer = null, currentMode = "arms";
let playerStep = null, playerIntro = null, lastState = null;

// Lottie animations (sample URLs — swap with your own if needed)
const ANIMS = {
  "Arm Raise (3 slow reps)": "https://assets8.lottiefiles.com/private_files/lf30_KvYwM2.json",
  "Elbow Flexion (3 slow reps)": "https://assets1.lottiefiles.com/packages/lf20_Stt6nK.json",
  "Sit ↔ Stand (3 reps)": "https://lottie.host/6e2a8267-stand-sit.json",
  "March in Place (10 steps)": "https://assets6.lottiefiles.com/packages/lf20_dyqj8qgn.json"
};
const TIPS = {
  "Arm Raise (3 slow reps)":[ "Stand square; keep both wrists visible.", "3–4s up, 3–4s down." ],
  "Elbow Flexion (3 slow reps)":[ "Shoulders relaxed; smooth bends.", "Match range both sides." ],
  "Sit ↔ Stand (3 reps)":[ "Feet shoulder-width; knees track over toes.", "Nose over toes to stand; control the sit." ],
  "March in Place (10 steps)":[ "Alternate knees to consistent height.", "Keep both feet in frame." ]
};

/* ======= Camera ======= */
async function startCam(){
  stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:1280,height:720},audio:false});
  ui.video.srcObject = stream; await ui.video.play(); resizeCanvas();
}
function stopCam(){ if(!stream)return; stream.getTracks().forEach(t=>t.stop()); stream=null; }
function resizeCanvas(){
  // buffer size (pixels)
  ui.overlay.width  = ui.video.videoWidth  || 1280;
  ui.overlay.height = ui.video.videoHeight || 720;
}
window.addEventListener('resize', resizeCanvas);
ui.video.addEventListener('loadedmetadata', resizeCanvas);

/* ======= Streaming to backend ======= */
function startSending(){
  if (timer) return;
  ui.dot.classList.add('ok');
  timer = setInterval(()=>{
    if (!ui.video.videoWidth) return;
    const c=document.createElement('canvas');
    c.width=ui.video.videoWidth; c.height=ui.video.videoHeight;
    c.getContext('2d').drawImage(ui.video,0,0,c.width,c.height);
    socket.emit('frame', { img_b64: c.toDataURL('image/jpeg',0.7), mode: currentMode });
  }, 120);
}
function stopSending(){
  if(!timer)return;
  clearInterval(timer); timer=null; ui.dot.classList.remove('ok');
}

/* ======= Overlay drawing (robust) ======= */
function normalizeOverlay(ov){
    if (!ov) return null;
  
    // Helper: detect if coords look normalized (<=1) or pixel (>1)
    const isNorm = (arr)=> {
      for (const p of arr) {
        const x = (p.x ?? p[0] ?? 0);
        const y = (p.y ?? p[1] ?? 0);
        if (x > 1.5 || y > 1.5) return false;
      }
      return true;
    };
  
    // A) { skeleton:{ kp:[{x,y,v,name}], lines:[[A,B],...] } }
    if (ov.skeleton && Array.isArray(ov.skeleton.kp)) {
      const pts = ov.skeleton.kp.map(p => ({
        x: p.x ?? 0, y: p.y ?? 0, v: (p.v ?? p.visibility ?? 1), name: p.name
      }));
      const edges = Array.isArray(ov.skeleton.lines) ? ov.skeleton.lines : [];
      return { pts, edges, norm: isNorm(pts) };
    }
  
    // B) { kp:[{x,y,v,name}], lines:[[A,B]...]}  (flat)
    if (Array.isArray(ov.kp)) {
      const pts = ov.kp.map(p => ({
        x: p.x ?? 0, y: p.y ?? 0, v: (p.v ?? p.visibility ?? 1), name: p.name
      }));
      const edges = Array.isArray(ov.lines) ? ov.lines : (Array.isArray(ov.segments) ? ov.segments : []);
      return { pts, edges, norm: isNorm(pts) };
    }
  
    // C) { points:["left_shoulder",...], segments:[[nameA,nameB]...], kps:{name:{x,y,v}} }
    if (Array.isArray(ov.points) && (Array.isArray(ov.segments) || Array.isArray(ov.lines))) {
      const dict = ov.kps || ov.keypoints_dict || {};
      const pts = ov.points.map(name => {
        const p = dict[name] || {};
        return { x: p.x ?? 0, y: p.y ?? 0, v: (p.v ?? p.visibility ?? 1), name };
      });
      const edges = (ov.segments || ov.lines || []);
      return { pts, edges, norm: isNorm(pts) };
    }
  
    // D) { keypoints:[{x,y,score,name?}], edges:[[i,j] or [nameA,nameB]] }
    if (Array.isArray(ov.keypoints)) {
      const pts = ov.keypoints.map((p,i)=>({
        x: p.x ?? 0, y: p.y ?? 0, v: (p.v ?? p.score ?? p.visibility ?? 1), name: p.name ?? String(i)
      }));
      const edges = ov.edges || ov.lines || [];
      return { pts, edges, norm: isNorm(pts) };
    }
  
    // E) { xy:[[x,y,v?],...], edges:[[i,j],...] }
    if (Array.isArray(ov.xy)) {
      const pts = ov.xy.map((arr,i)=>({ x: arr[0]??0, y: arr[1]??0, v: (arr[2]??1), name: String(i) }));
      const edges = ov.edges || ov.lines || [];
      return { pts, edges, norm: isNorm(pts) };
    }
  
    // F) { landmarks:[{x,y,visibility}], ... } (MediaPipe-like)
    if (Array.isArray(ov.landmarks) || Array.isArray(ov.normalizedLandmarks)) {
      const arr = ov.landmarks || ov.normalizedLandmarks;
      const pts = arr.map((p,i)=>({ x:p.x??0, y:p.y??0, v:(p.visibility??1), name:String(i) }));
      const edges = ov.edges || ov.connections || [];
      return { pts, edges, norm: isNorm(pts) };
    }
  
    // If you ever send just a dict of name->{x,y,v}
    if (ov.kps && typeof ov.kps === 'object') {
      const names = Object.keys(ov.kps);
      const pts = names.map(n=>{
        const p = ov.kps[n] || {};
        return { x:p.x??0, y:p.y??0, v:(p.v??p.visibility??1), name:n };
      });
      const edges = ov.lines || ov.segments || [];
      return { pts, edges, norm: isNorm(pts) };
    }
  
    return null;
  }
  function drawOverlay(ov){
    const ctx = ui.overlay.getContext('2d');
    const W = ui.overlay.width  || 1280;
    const H = ui.overlay.height || 720;
    ctx.clearRect(0,0,W,H);
  
    const n = normalizeOverlay(ov);
    if (!n) {
      // Debug tag so you know the canvas is visible
      ctx.fillStyle = 'rgba(255,80,80,0.9)';
      ctx.font = '12px ui-monospace, monospace';
      ctx.fillText('NO OVERLAY', 10, 18);
      return;
    }
  
    const { pts, edges, norm } = n;
  
    // Build lookup by name for named edges
    const byName = new Map();
    pts.forEach((p,i)=>{ if (p.name!=null) byName.set(p.name, {i, p}); });
  
    // Draw edges
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#69ddff';
    for (const e of edges) {
      let A=null, B=null;
      if (Array.isArray(e) && e.length>=2) {
        const [a,b] = e;
        if (typeof a === 'number' && typeof b === 'number') {
          A = pts[a]; B = pts[b];
        } else {
          A = byName.get(a)?.p; B = byName.get(b)?.p;
        }
      }
      if (!A || !B) continue;
      if ((A.v ?? 1) < 0.35 || (B.v ?? 1) < 0.35) continue;
  
      const ax = norm ? A.x * W : A.x;
      const ay = norm ? A.y * H : A.y;
      const bx = norm ? B.x * W : B.x;
      const by = norm ? B.y * H : B.y;
  
      ctx.beginPath(); ctx.moveTo(ax, ay); ctx.lineTo(bx, by); ctx.stroke();
    }
  
    // Draw points
    // Draw points (bigger dots)
for (const p of pts) {
    if ((p.v ?? 1) < 0.35) continue;
    const x = norm ? p.x * W : p.x;
    const y = norm ? p.y * H : p.y;
  
    // outer ring
    ctx.beginPath();
    ctx.arc(x, y, 9, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(10,14,39,0.75)';
    ctx.fill();
    ctx.lineWidth = 3.5;
    ctx.strokeStyle = '#5ac8fa';
    ctx.stroke();
  
    // inner dot
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#5ac8fa';
    ctx.fill();
  }
  }
  

/* ======= Lottie helpers ======= */
function loadStepAnim(name){
  if (playerStep){ try{playerStep.destroy()}catch(e){} }
  playerStep = lottie.loadAnimation({ container: ui.stepAnim, renderer:'svg', loop:true, autoplay:true, path: ANIMS[name] || ANIMS["Arm Raise (3 slow reps)"] });
}
let introOpen=false, introKeyShown=null, introTimerId=null;
function stepKey(s){ return s ? [s.step_name, s.expected_mode, s.target_reps].join("|") : ""; }

function showIntro(name, tips, key){
  if (introOpen || (introKeyShown && introKeyShown===key)) return;
  introOpen = true; introKeyShown = key;
  stopSending();
  if (playerIntro){ try{playerIntro.destroy()}catch(e){} }
  playerIntro = lottie.loadAnimation({ container: ui.intro.anim, renderer:'svg', loop:true, autoplay:true, path: ANIMS[name] || ANIMS["Arm Raise (3 slow reps)"] });
  ui.intro.title.textContent = name || "Get ready…";
  ui.intro.list.innerHTML = "";
  (tips||["Follow the animation carefully.","Keep the required joints visible.","We’ll start after the countdown."])
    .forEach(t=>{ const li=document.createElement('li'); li.textContent=t; ui.intro.list.appendChild(li); });
  ui.intro.el.style.display='flex';
  let c=3; ui.intro.countdown.textContent=String(c);
  if (introTimerId) clearInterval(introTimerId);
  introTimerId = setInterval(()=>{
    c--; ui.intro.countdown.textContent=String(c);
    if (c<=0){
      clearInterval(introTimerId); introTimerId=null; finishIntroAndStart();
    }
  },1000);
  ui.intro.skip.onclick=()=>{ if(introTimerId){clearInterval(introTimerId); introTimerId=null;} finishIntroAndStart(); };
}
function finishIntroAndStart(){
  ui.intro.el.style.display='none'; introOpen=false;
  try{ playerIntro && playerIntro.destroy(); }catch(e){}
  startSending();
  const mode = (lastState && lastState.expected_mode) ? lastState.expected_mode : currentMode;
  socket.emit('start_task',{mode}); socket.emit('resume_step',{mode});
}

/* ======= Sockets ======= */
socket.on('connect', ()=> ui.cue.textContent="Connected. Click Start when ready.");

socket.on('metrics',(p)=>{
  // Render skeleton & show metrics JSON
  if (p?.overlays) drawOverlay(p.overlays);
  if (p?.metrics)  ui.metrics.textContent = JSON.stringify(p.metrics, null, 2);
  if (p?.cue)      ui.cue.textContent = p.cue;
});

socket.on('protocol_state',(s)=>{
  if(!s) return;
  const keyPrev = stepKey(lastState);
  const keyNow  = stepKey(s);
  const stepChanged = keyPrev !== keyNow;
  lastState = s;

  const { step_name, expected_mode, reps_done, target_reps, hint, phase } = s;
  if (expected_mode) currentMode = expected_mode;

  ui.stepTitle.textContent = step_name || "—";
  ui.stepSub.textContent = phase ? `Phase: ${phase}` : "—";
  ui.repsDone.textContent = reps_done ?? 0;
  ui.repsTarget.textContent = target_reps ?? 0;
  ui.progress.style.width = target_reps ? Math.min(100, Math.round((reps_done/target_reps)*100)) + "%" : "0%";
  if (step_name) loadStepAnim(step_name);
  ui.tips.textContent = (TIPS[step_name]?.join(" • ")) || hint || "Follow the animation.";

  // Show intro once per step while idle
  if (phase === "idle" && stepChanged) showIntro(step_name, TIPS[step_name], keyNow);
  // Ensure overlay closed when active
  if (phase === "active"){ if (introTimerId){clearInterval(introTimerId); introTimerId=null;} ui.intro.el.style.display='none'; introOpen=false; startSending(); }
});

// REPLACE your existing socket.on('final_report', ...) with this:
socket.on('final_report', (rep)=>{
    // stop streaming/camera
    stopSending(); 
    stopCam(); 
    ui.btnStart.disabled = false; 
    ui.btnStop.disabled = true;
  
    // Show overall score on-screen (if you already show it elsewhere, keep both)
    const score = rep?.report?.overall_score;
    if (typeof score === 'number') {
      ui.cue.textContent = `Session complete — Overall Score: ${score}`;
    } else {
      ui.cue.textContent = "Session complete.";
    }
  
    // ---- NEW: kick off Gemini analysis and show it in the AI panel ----
    ui.aiContent.textContent = "Analyzing your session with AI…";
    ui.aiLinks.style.display = "none";
  
    const fname = rep?.storage?.filename;
    const dl = rep?.storage?.download_url; // e.g., /reports/<file>.json
  
    // If we have a saved JSON file, show links and call the AI endpoint
    if (fname && dl) {
      // show JSON link
      ui.jsonLink.href = dl;
      ui.aiLinks.style.display = "flex";
  
      // fetch Gemini analysis
      fetch(`/api/reports/ai/${encodeURIComponent(fname)}`)
        .then(r => r.ok ? r.json() : Promise.reject(new Error(`HTTP ${r.status}`)))
        .then(j => {
          if (j && j.ai_report) {
            ui.aiContent.textContent = j.ai_report;
          } else if (j && j.error) {
            ui.aiContent.textContent = `AI analysis unavailable: ${j.error}`;
          } else {
            ui.aiContent.textContent = "AI analysis unavailable.";
          }
        })
        .catch(err => {
          ui.aiContent.textContent = `AI analysis failed: ${err.message}`;
        });
    } else {
      // Fallback if the backend didn't include a saved report (shouldn't happen)
      ui.aiContent.textContent = "Session summary saved, but AI analysis could not be started.";
    }
  });
  
  

/* ======= Controls ======= */
ui.btnStart.onclick = async ()=>{
  ui.btnStart.disabled=true; ui.btnStop.disabled=false; ui.cue.textContent="Starting…";
  await startCam();
  socket.emit('start_protocol',{});
};
ui.btnStop.onclick = ()=>{
  socket.emit('stop_protocol',{});
  stopSending(); stopCam();
  ui.btnStart.disabled=false; ui.btnStop.disabled=true;
};
ui.btnToggle.onclick = ()=>{
  const hide = ui.video.style.display!=='none';
  ui.video.style.display = hide?'none':'block';
  ui.overlay.style.display = hide?'none':'block';
  ui.btnToggle.textContent = hide?'Show Video':'Hide Video';
};
// Safari autoplay unlock
document.addEventListener('click', ()=>{ if (ui.video && ui.video.paused && stream) ui.video.play().catch(()=>{}); }, {once:true});
</script>
</body>
</html>
